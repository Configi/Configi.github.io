{
    "docs": [
        {
            "location": "/", 
            "text": "Configi\n\uf0c1\n\n\nA minimalistic infrastructure automation and configuration management software. It is MIT licensed (including the core modules).\n\n\nConfigi can manage several aspects of system configuration, security and maintenance. Note that this will depend on the availability of Configi modules applicable for your requirement.\n\n\nFor now Configi is Linux only. There are no plans to support Windows. *BSD support possibly in the future.\n\n\nSee \nWikipedia\n for more information on the topic of configuration management.\n\n\n\n\nWhy?\n\uf0c1\n\n\nThere are several configuration management software in existence but I find most are bloated both in resource usage and features. The others in the minimalist camp also fall short due to complicated policy, module or extension writing. The latter are usually not far off from shell script wrappers.\n\n\nConfigi was inspired by CFEngine 3, Chef and Ansible. You may see some similarities with these configuration management software in Configi. Especially CFEngine 3, where we borrowed the concepts introduced by the Promise Theory and Computer Immunology.\n\n\nVisit M. Burgess' \npage\n for essays, articles and papers regarding Promise Theory and system administration. I do not claim full compliance to the theory so Configi should not be considered a complete replacement for CFEngine 3.\n\n\nLua\n is a very good programming language. Its language features lend to simple core and module code. In the same spirit as Lua, the Configi core is very small. With the help of \nMoonscript\n, Configi provides policy writers the capabilities of Lua but with additional reduced cognitive overhead.\n\n\nChoosing the right tool is not a rational matter. If the design decisions outlined below aligns with your requirements then please give Configi a try.\n\n\n\n\nDesign decisions\n\uf0c1\n\n\n\n\nCompiled-in modules and policy\n\n\n\n\nThe Configi executable (cfg) with all modules (as of 0.9.0) compiled-in is around 500KiB. In practice this should be less because Configi modules are compiled-in. You can choose the modules only applicable for your policy or host.\n\n\nIt's also possible to have your policy built-in during compilation of the executable.\n\n\n\n\nPull or push model\n\n\n\n\nThe ideal system would be a pull-based system but if needed Configi can also emulate a push-based system.\n\n\n\n\nNo packaging required\n\n\n\n\nYou can just copy the Configi (cfg) executable to a host and have it configuring the host in no time.\n\n\n\n\nNo parallel execution\n\n\n\n\nParallel execution requires adding features that complicates and bloats the runtime.\n\n\n\n\nMinimal resource usage\n\n\n\n\nBy avoiding parallel execution and being built in Lua we are guaranteeing very little resources required.\n\n\n\n\nDeterministic ordering\n\n\n\n\nBy avoiding parallel execution policies are evaluated from top to bottom.\n\n\n\n\nDepend on existing host tooling\n\n\n\n\nAs much as possible Configi makes use of host tools (e.g coreutils, busybox, native package manager, native process manager). If bypassing host tooling is required or there is none available, Configi modules has the capability to drop down to Lua and/or C for operations.\n\n\n\n\nThe only reporting mechanism is through Syslog\n\n\n\n\nTo be light as possible, it makes sense to support the most widespread reporting facility. If you need to monitor or gather reports from all your hosts you will need to set up consolidated remote syslogging and automated reporting.\n\n\n\n\nExample policy\n\uf0c1\n\n\nfile.directory\"/tmp/dir\"\n  comment: \"Create directory if running on Gentoo\"\n  context: fact.osfamily.gentoo\n  mode: \"0700\"\n  notify: \"touch\"\n\nyum.present\"mtr\"\n  context: fact.osfamily.centos\n\nfile.absent\"/tmp/dir\"\n  notify: \"touch\"\n\nfile.touch\"/tmp/dir\"\n  comment: \"Handle 'touch' notifications. This is only executed once.\"\n  handle: \"touch\"\n\n\n\n\n\nPolicies are written in Moonscript\n\uf0c1\n\n\nMoonscript is a dynamic scripting language that has a clean syntax using significant whitespace.\n\n\nFor reference, see the Moonscript \nLanguage Guide\n.\n\n\n\n\nMailing list\n\uf0c1\n\n\nJoin the mailing list if you need help or have Configi module requests. Bug reports and patches are also very much welcome.\n\n\nTo join, send an email to configi-request@freelists.org with 'subscribe' in the Subject field OR by\nvisiting the list page at \nFreelists/Configi\n.", 
            "title": "Home"
        }, 
        {
            "location": "/#configi", 
            "text": "A minimalistic infrastructure automation and configuration management software. It is MIT licensed (including the core modules).  Configi can manage several aspects of system configuration, security and maintenance. Note that this will depend on the availability of Configi modules applicable for your requirement.  For now Configi is Linux only. There are no plans to support Windows. *BSD support possibly in the future.  See  Wikipedia  for more information on the topic of configuration management.", 
            "title": "Configi"
        }, 
        {
            "location": "/#why", 
            "text": "There are several configuration management software in existence but I find most are bloated both in resource usage and features. The others in the minimalist camp also fall short due to complicated policy, module or extension writing. The latter are usually not far off from shell script wrappers.  Configi was inspired by CFEngine 3, Chef and Ansible. You may see some similarities with these configuration management software in Configi. Especially CFEngine 3, where we borrowed the concepts introduced by the Promise Theory and Computer Immunology.  Visit M. Burgess'  page  for essays, articles and papers regarding Promise Theory and system administration. I do not claim full compliance to the theory so Configi should not be considered a complete replacement for CFEngine 3.  Lua  is a very good programming language. Its language features lend to simple core and module code. In the same spirit as Lua, the Configi core is very small. With the help of  Moonscript , Configi provides policy writers the capabilities of Lua but with additional reduced cognitive overhead.  Choosing the right tool is not a rational matter. If the design decisions outlined below aligns with your requirements then please give Configi a try.", 
            "title": "Why?"
        }, 
        {
            "location": "/#design-decisions", 
            "text": "Compiled-in modules and policy   The Configi executable (cfg) with all modules (as of 0.9.0) compiled-in is around 500KiB. In practice this should be less because Configi modules are compiled-in. You can choose the modules only applicable for your policy or host.  It's also possible to have your policy built-in during compilation of the executable.   Pull or push model   The ideal system would be a pull-based system but if needed Configi can also emulate a push-based system.   No packaging required   You can just copy the Configi (cfg) executable to a host and have it configuring the host in no time.   No parallel execution   Parallel execution requires adding features that complicates and bloats the runtime.   Minimal resource usage   By avoiding parallel execution and being built in Lua we are guaranteeing very little resources required.   Deterministic ordering   By avoiding parallel execution policies are evaluated from top to bottom.   Depend on existing host tooling   As much as possible Configi makes use of host tools (e.g coreutils, busybox, native package manager, native process manager). If bypassing host tooling is required or there is none available, Configi modules has the capability to drop down to Lua and/or C for operations.   The only reporting mechanism is through Syslog   To be light as possible, it makes sense to support the most widespread reporting facility. If you need to monitor or gather reports from all your hosts you will need to set up consolidated remote syslogging and automated reporting.", 
            "title": "Design decisions"
        }, 
        {
            "location": "/#example-policy", 
            "text": "file.directory\"/tmp/dir\"\n  comment: \"Create directory if running on Gentoo\"\n  context: fact.osfamily.gentoo\n  mode: \"0700\"\n  notify: \"touch\"\n\nyum.present\"mtr\"\n  context: fact.osfamily.centos\n\nfile.absent\"/tmp/dir\"\n  notify: \"touch\"\n\nfile.touch\"/tmp/dir\"\n  comment: \"Handle 'touch' notifications. This is only executed once.\"\n  handle: \"touch\"", 
            "title": "Example policy"
        }, 
        {
            "location": "/#policies-are-written-in-moonscript", 
            "text": "Moonscript is a dynamic scripting language that has a clean syntax using significant whitespace.  For reference, see the Moonscript  Language Guide .", 
            "title": "Policies are written in Moonscript"
        }, 
        {
            "location": "/#mailing-list", 
            "text": "Join the mailing list if you need help or have Configi module requests. Bug reports and patches are also very much welcome.  To join, send an email to configi-request@freelists.org with 'subscribe' in the Subject field OR by\nvisiting the list page at  Freelists/Configi .", 
            "title": "Mailing list"
        }, 
        {
            "location": "/download/", 
            "text": "Linux Distribution support\n\uf0c1\n\n\nTested on Gentoo, Debian, Centos, OpenWRT and Alpine Linux.\n\n\nRuns fine on OpenWRT mipsel and mips targets with little as 32MB RAM. Here's a memory usage snapshot of a week-old Configi process running on a Broadcom MIPS board. The policy is executed every half hour. All 0.9.0 modules compiled in.\n\n\nVmPeak:     1356 kB\nVmSize:     1356 kB\nVmLck:         0 kB\nVmPin:         0 kB\nVmHWM:       776 kB\nVmRSS:       776 kB\nVmData:      364 kB\nVmStk:       136 kB\nVmExe:       348 kB\nVmLib:       476 kB\nVmPTE:        12 kB\nVmSwap:        0 kB\n\n\n\nIt should compile on any recent Linux distributions but it may lack the necessary modules to be useful. This should improve with module contributions for your distribution.\n\n\nDownload\n\uf0c1\n\n\nconfigi-1.0.0\n\n\nRequirements\n\uf0c1\n\n\nThe build time requirements are GNUMake and a compiler-toolchain such as GCC or Clang.\n\n\nRuntime Dependencies will depend on the module that you want to compile in. Check the module documentation. The only runtime dependency for the \ncfg\n binary is a LIBC.\n\n\n# ldd bin/cfg\n    /lib/ld-musl-x86_64.so.1 (0x7f6167d50000)\n    libc.musl-x86_64.so.1 =\n /lib/ld-musl-x86_64.so.1 (0x7f6167d50000)\n\n\n\nBuilding\n\uf0c1\n\n\nThe build system is from \nOmnia\n. Underneath it's a non-recursive Makefile.\n\n\nUnpack the archive, change to the directory then run \nmake\n.\n\n\n# tar -xf configi-1.0.0.tar.gz\n# cd configi-1.0.0\n# make\n\n\n\nRunning\n\uf0c1\n\n\n# cd configi-1.0.0\n# ./cfg -f path_to_your_policy", 
            "title": "Download"
        }, 
        {
            "location": "/download/#linux-distribution-support", 
            "text": "Tested on Gentoo, Debian, Centos, OpenWRT and Alpine Linux.  Runs fine on OpenWRT mipsel and mips targets with little as 32MB RAM. Here's a memory usage snapshot of a week-old Configi process running on a Broadcom MIPS board. The policy is executed every half hour. All 0.9.0 modules compiled in.  VmPeak:     1356 kB\nVmSize:     1356 kB\nVmLck:         0 kB\nVmPin:         0 kB\nVmHWM:       776 kB\nVmRSS:       776 kB\nVmData:      364 kB\nVmStk:       136 kB\nVmExe:       348 kB\nVmLib:       476 kB\nVmPTE:        12 kB\nVmSwap:        0 kB  It should compile on any recent Linux distributions but it may lack the necessary modules to be useful. This should improve with module contributions for your distribution.", 
            "title": "Linux Distribution support"
        }, 
        {
            "location": "/download/#download", 
            "text": "configi-1.0.0", 
            "title": "Download"
        }, 
        {
            "location": "/download/#requirements", 
            "text": "The build time requirements are GNUMake and a compiler-toolchain such as GCC or Clang.  Runtime Dependencies will depend on the module that you want to compile in. Check the module documentation. The only runtime dependency for the  cfg  binary is a LIBC.  # ldd bin/cfg\n    /lib/ld-musl-x86_64.so.1 (0x7f6167d50000)\n    libc.musl-x86_64.so.1 =  /lib/ld-musl-x86_64.so.1 (0x7f6167d50000)", 
            "title": "Requirements"
        }, 
        {
            "location": "/download/#building", 
            "text": "The build system is from  Omnia . Underneath it's a non-recursive Makefile.  Unpack the archive, change to the directory then run  make .  # tar -xf configi-1.0.0.tar.gz\n# cd configi-1.0.0\n# make", 
            "title": "Building"
        }, 
        {
            "location": "/download/#running", 
            "text": "# cd configi-1.0.0\n# ./cfg -f path_to_your_policy", 
            "title": "Running"
        }, 
        {
            "location": "/license/", 
            "text": "License\n\uf0c1\n\n\n\n\nConfigi\n\uf0c1\n\n\nThe Configi core and modules are free software distributed under the terms of the MIT license, reproduced here. Configi may be used for any purpose, including commercial purposes, at absolutely no cost.\n\n\nConfigi will be 100% free. There will be no open core, enterprise-only versions or components. Others are free to incorporate Configi into their commercial product if desired.\n\n\n\n\nCopyright (c) 2016, Eduardo Tongson \n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n\n\n\nSee \nopensource.org/licenses/MIT\n.\n\n\nIncluded projects\n\uf0c1\n\n\nAll included opensource projets are MIT licensed. Visit the project homepage for more information.\n\n\n\n\n\n\n\n\nProject\n\n\nVersion\n\n\nLicense\n\n\n\n\n\n\n\n\n\n\nLua\n\n\n5.3.3\n\n\nMIT\n\n\n\n\n\n\nLuaposix\n\n\n33.4.0\n\n\nMIT\n\n\n\n\n\n\nLinotify\n\n\n0.4\n\n\nMIT\n\n\n\n\n\n\ncrc32lua\n\n\n0.3.20111128-1\n\n\nMIT\n\n\n\n\n\n\nsha2\n\n\n201412011639-r7\n\n\nMIT\n\n\n\n\n\n\nMoonscript\n\n\n0.0.4\n\n\nMIT\n\n\n\n\n\n\nLPeg\n\n\n1.0.0\n\n\nMIT", 
            "title": "License"
        }, 
        {
            "location": "/license/#license", 
            "text": "", 
            "title": "License"
        }, 
        {
            "location": "/license/#configi", 
            "text": "The Configi core and modules are free software distributed under the terms of the MIT license, reproduced here. Configi may be used for any purpose, including commercial purposes, at absolutely no cost.  Configi will be 100% free. There will be no open core, enterprise-only versions or components. Others are free to incorporate Configi into their commercial product if desired.   Copyright (c) 2016, Eduardo Tongson   Permission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:  The above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.   See  opensource.org/licenses/MIT .", 
            "title": "Configi"
        }, 
        {
            "location": "/license/#included-projects", 
            "text": "All included opensource projets are MIT licensed. Visit the project homepage for more information.     Project  Version  License      Lua  5.3.3  MIT    Luaposix  33.4.0  MIT    Linotify  0.4  MIT    crc32lua  0.3.20111128-1  MIT    sha2  201412011639-r7  MIT    Moonscript  0.0.4  MIT    LPeg  1.0.0  MIT", 
            "title": "Included projects"
        }, 
        {
            "location": "/modules/", 
            "text": "Generated by LDoc\n\uf0c1\n\n\nModule Documentation", 
            "title": "Modules"
        }, 
        {
            "location": "/modules/#generated-by-ldoc", 
            "text": "Module Documentation", 
            "title": "Generated by LDoc"
        }, 
        {
            "location": "/reference/about_modules/", 
            "text": "About Configi modules\n\uf0c1\n\n\n\n\nConfigi modules are regular Lua modules which return a table. It was decided to call them modules too since they are essentially the same as Lua modules. The module terminology is also very common and easily understood in the software industry.\n\n\nHere is a contrived module to demonstrate the parts:\n\n\nlocal ENV, M, example = {}, {}, {}\nlocal cfg = require\nconfigi\n\nlocal lib = require\nlib\n\nlocal cmd = lib.cmd\n_ENV = ENV\n\nM.required = { \nwhat\n }\nM.alias = {}\nM.alias.task = { \nwork\n }\n\nlocal done = function()\nend\n\nfunction example.present(S)\n    M.parameters = { \ntask\n }\n    M.report = {\n        repaired = \nexample.present: Ok\n,\n            kept = \nexample.present: Skipped\n,\n          failed = \nexample.presnet: Error\n\n    }\n    return function(P)\n        P.what = S\n        local F, R = cfg.init(P, M)\n        if done() then\n            return F.kept(P.what)\n        end\n        return F.result(P.task, F.run(cmd.something{ action = P.task }))\n    end\nend\nexample.done = example.present\nreturn example\n\n\n\n\nAnatomy of a Configi module\n\uf0c1\n\n\n\n\nLocal variable declaration and loaded Lua modules\n\n\nlocal ENV, M, example = {}, {}, {}\nlocal cfg = require\nconfigi\n\nlocal lib = require\nlib\n\nlocal cmd = lib.cmd\n_ENV = ENV\n\n\n\n\nIt is good practice to localize Lua modules and variables in the first few lines of the function. For example, here we have the \nENV\n table, \nM\n table (used later) and the table to be returned as the module.\n\n\nThe rest of the local declaration specifies the Lua modules that are required. If you look at the example above or at the existing Configi modules you will notice that the following Lua modules are usually \nrequired\n.\n\n\n\n\n\n\n\n\nModule\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nconfigi\n\n\nThe core Lua module of Configi. It is the \nonly\n required Lua module.\n\n\n\n\n\n\nlib\n\n\nThe official standard library / utility belt / batteries of Configi. Includes auxillary Lua functions and extensions to the luaposix module.\n\n\n\n\n\n\n\n\nFeel free to submit patches to extend or fix something in these modules.\n\n\n\n\nRequired parameters and aliases\n\n\nM.required = { \nwhat\n }\nM.alias = {}\nM.alias.task = { \nwork\n }\n\n\n\n\nThe middle part of the header is where the required parameters to the Configi module and aliases are declared. The \nM\n table assigned to a local table earlier is what we're going to use to the store these.\n\n\nM.required\n is the required parameter by \nall\n functions of the module. Here the parameters \nwhat\n is required and if not present in the policy, will produce an error. Before assigning aliases to a parameter, the \nM.alias\n table should be declared first.\n\n\n\n\nLocal functions\n\n\nlocal done = function()\nend\n\n\n\n\nFunctions local to the module should be declared at the end of the header. You can see it in practice in the above module when done() was assigned a function.\n\n\n\n\nModule functions\n\n\nfunction example.present(S)\n\n\n\nFunctions performs the actual execution of commands or call operations that change the state of a host. The structure of a function follows the \nskip or execute or fail\n pattern.\n\n\nWhen naming the function, keep in mind that you are going to describe the state of a promise. The parameter \nS\n is a string that will be the subject of a promise.\n\n\n\n\nFunction header\n\n\nM.parameters = { \"task\" }\nM.report = {\n    repaired = \"example.present: Ok\",\n        kept = \"example.present: Skipped\",\n      failed = \"example.present: Error\"\n}\n\n\n\nEach function in the Configi module has their own headers. This is where the declaration of the \nM.parameters\n and \nM.report\n tables is done. The \nM.parameters\n table is a sequence of parameters valid to the function. If a parameter not in this sequence is used in a policy, it produces a warning.\n\n\nThe \nM.report\n table is a dictionary of strings used for reporting and logging. The \nrepaired\n key corresponds to a string value that is used for reporting if changes were applied; \nkept\n if no changes were made; \nfailed\n if an error was encountered.\n\n\n\n\nFunction proper\n\n\nreturn function(P)\n    P.what = S\n    local F, R = cfg.init(P, M)\n    if done() then\n        return F.kept(P.what)\n    end\n    return F.result(P.task, F.run(cmd.something{ action = P.task }))\nend\n\n\n\nA function is returned and it takes a single table as the argument. The subject string \nS\n is assigned to one of the parameters (usually a required parameter). In this case, the key \nwhat\n is  assigned \nS\n.\n\n\nYou might be wondering why this is returning a closure. A closure allows for calling the promise/function like this:\n\n\nexample.present\"subject\"\n  task: \"something\"\n\n\n\nHere \nsubject\n is the string assigned to \nS\n and then assigned to \nP.what\n. The string \nsomething\n is assigned to \nP.task\n\n\ncfg.init\n takes two arguments, the \nP\n (parameters) table and \nM\n (used for module attributes) table. It is called by each module function to initialize \nP\n and returns the tables for module functions \nF\n and \nR\n a table that is used to store results.\n\n\nP\n argument to the function is the dictionary of parameter-arguments. They are written as \nparameter: \"argument\"\n (Moonscript) or \nparameter = \"argument\"\n (Lua) in policies.\n\n\nConfigi has support for handlers. The value of the \nnotify_kept\n parameter is called when a function is skipped. The value of \nnotify\n when the function succeeds with the prescribed operation. The value of to \nnotify_failed\n when the operation fails.\n\n\nThe following example promise if applied triggers the handler tagged with \nrepaired\n:\n\n\nexample.present\"subject\"\n  notify: \"repaired\"\n  task: \"something\"\n\n\n\nSome modules require you to micromanage operations, messages and results. Here's an equivalent of the function above:\n\n\nfunction example.present(S)\n    M.parameters = { \ntask\n }\n    M.report = {\n        repaired = \nexample.present: Ok\n,\n            kept = \nexample.present: Skipped\n,\n          failed = \nexample.presnet: Error\n\n    }\n    return function(P)\n        P.what = S\n        local F, R = cfg.init(P, M)\n        if done() then\n            F.msg(P.task, M.report.kept, nil)\n            R.notify_kept = P.notify_kept\n            return R\n        end\n        if F.run(cmd.something, { action = P.task }) then\n            F.msg(P.task, M.report.repaired, true)\n            R.notify = P.notify\n            R.repaired = true\n        else\n            R.notify_failed = P.notify_failed\n            R.failed = true\n        end\n        return R\n    end\nend\nexample.done = example.present\nreturn example\n\n\n\n\n\n\nFooter\n\n\nexample.done = example.present\nreturn example\n\n\n\nThis is where function aliases are declared and the table return statement of a Lua module.\n\n\nDocumentation\n\uf0c1\n\n\nModule and function documentation is generated using \nLDoc\n. See the existing modules for examples.\n\n\nNotes\n\uf0c1\n\n\n\n\n\n\nThe list of reserved parameters:\n\n\n\n\ncomment\n\n\ndebug\n\n\ntest\n\n\nsyslog\n\n\nlog\n\n\nhandle\n\n\nregister\n\n\ncontext\n\n\nnotify\n\n\nnotify_failed\n\n\nnotify_kept\n\n\n\n\n\n\n\n\nIt is the module's responsibility to determine whether anything needs to be done. An operation that modifies the system state should be convergent.\n\n\n\n\n\n\nModules are auto-loaded based on the name of the called module function. For example in a script containing the following snippet, module \nexample\n is auto-loaded.\n\n\n\n\n\n\nexample.present\nsubject\n\n  task: \nyes\n\n\n\n\n\n\n\n\n\nWhen writing modules run it through the excellent linting tool, Luacheck \nhttps://github.com/mpeterv/luacheck/\n.\n\n\n\n\n\n\nRemember that a configuration management software's real strength comes from the quality of its modules.", 
            "title": "About modules"
        }, 
        {
            "location": "/reference/about_modules/#about-configi-modules", 
            "text": "Configi modules are regular Lua modules which return a table. It was decided to call them modules too since they are essentially the same as Lua modules. The module terminology is also very common and easily understood in the software industry.  Here is a contrived module to demonstrate the parts:  local ENV, M, example = {}, {}, {}\nlocal cfg = require configi \nlocal lib = require lib \nlocal cmd = lib.cmd\n_ENV = ENV\n\nM.required = {  what  }\nM.alias = {}\nM.alias.task = {  work  }\n\nlocal done = function()\nend\n\nfunction example.present(S)\n    M.parameters = {  task  }\n    M.report = {\n        repaired =  example.present: Ok ,\n            kept =  example.present: Skipped ,\n          failed =  example.presnet: Error \n    }\n    return function(P)\n        P.what = S\n        local F, R = cfg.init(P, M)\n        if done() then\n            return F.kept(P.what)\n        end\n        return F.result(P.task, F.run(cmd.something{ action = P.task }))\n    end\nend\nexample.done = example.present\nreturn example", 
            "title": "About Configi modules"
        }, 
        {
            "location": "/reference/about_modules/#anatomy-of-a-configi-module", 
            "text": "Local variable declaration and loaded Lua modules  local ENV, M, example = {}, {}, {}\nlocal cfg = require configi \nlocal lib = require lib \nlocal cmd = lib.cmd\n_ENV = ENV  It is good practice to localize Lua modules and variables in the first few lines of the function. For example, here we have the  ENV  table,  M  table (used later) and the table to be returned as the module.  The rest of the local declaration specifies the Lua modules that are required. If you look at the example above or at the existing Configi modules you will notice that the following Lua modules are usually  required .     Module  Description      configi  The core Lua module of Configi. It is the  only  required Lua module.    lib  The official standard library / utility belt / batteries of Configi. Includes auxillary Lua functions and extensions to the luaposix module.     Feel free to submit patches to extend or fix something in these modules.   Required parameters and aliases  M.required = {  what  }\nM.alias = {}\nM.alias.task = {  work  }  The middle part of the header is where the required parameters to the Configi module and aliases are declared. The  M  table assigned to a local table earlier is what we're going to use to the store these.  M.required  is the required parameter by  all  functions of the module. Here the parameters  what  is required and if not present in the policy, will produce an error. Before assigning aliases to a parameter, the  M.alias  table should be declared first.   Local functions  local done = function()\nend  Functions local to the module should be declared at the end of the header. You can see it in practice in the above module when done() was assigned a function.   Module functions  function example.present(S)  Functions performs the actual execution of commands or call operations that change the state of a host. The structure of a function follows the  skip or execute or fail  pattern.  When naming the function, keep in mind that you are going to describe the state of a promise. The parameter  S  is a string that will be the subject of a promise.   Function header  M.parameters = { \"task\" }\nM.report = {\n    repaired = \"example.present: Ok\",\n        kept = \"example.present: Skipped\",\n      failed = \"example.present: Error\"\n}  Each function in the Configi module has their own headers. This is where the declaration of the  M.parameters  and  M.report  tables is done. The  M.parameters  table is a sequence of parameters valid to the function. If a parameter not in this sequence is used in a policy, it produces a warning.  The  M.report  table is a dictionary of strings used for reporting and logging. The  repaired  key corresponds to a string value that is used for reporting if changes were applied;  kept  if no changes were made;  failed  if an error was encountered.   Function proper  return function(P)\n    P.what = S\n    local F, R = cfg.init(P, M)\n    if done() then\n        return F.kept(P.what)\n    end\n    return F.result(P.task, F.run(cmd.something{ action = P.task }))\nend  A function is returned and it takes a single table as the argument. The subject string  S  is assigned to one of the parameters (usually a required parameter). In this case, the key  what  is  assigned  S .  You might be wondering why this is returning a closure. A closure allows for calling the promise/function like this:  example.present\"subject\"\n  task: \"something\"  Here  subject  is the string assigned to  S  and then assigned to  P.what . The string  something  is assigned to  P.task  cfg.init  takes two arguments, the  P  (parameters) table and  M  (used for module attributes) table. It is called by each module function to initialize  P  and returns the tables for module functions  F  and  R  a table that is used to store results.  P  argument to the function is the dictionary of parameter-arguments. They are written as  parameter: \"argument\"  (Moonscript) or  parameter = \"argument\"  (Lua) in policies.  Configi has support for handlers. The value of the  notify_kept  parameter is called when a function is skipped. The value of  notify  when the function succeeds with the prescribed operation. The value of to  notify_failed  when the operation fails.  The following example promise if applied triggers the handler tagged with  repaired :  example.present\"subject\"\n  notify: \"repaired\"\n  task: \"something\"  Some modules require you to micromanage operations, messages and results. Here's an equivalent of the function above:  function example.present(S)\n    M.parameters = {  task  }\n    M.report = {\n        repaired =  example.present: Ok ,\n            kept =  example.present: Skipped ,\n          failed =  example.presnet: Error \n    }\n    return function(P)\n        P.what = S\n        local F, R = cfg.init(P, M)\n        if done() then\n            F.msg(P.task, M.report.kept, nil)\n            R.notify_kept = P.notify_kept\n            return R\n        end\n        if F.run(cmd.something, { action = P.task }) then\n            F.msg(P.task, M.report.repaired, true)\n            R.notify = P.notify\n            R.repaired = true\n        else\n            R.notify_failed = P.notify_failed\n            R.failed = true\n        end\n        return R\n    end\nend\nexample.done = example.present\nreturn example   Footer  example.done = example.present\nreturn example  This is where function aliases are declared and the table return statement of a Lua module.", 
            "title": "Anatomy of a Configi module"
        }, 
        {
            "location": "/reference/about_modules/#documentation", 
            "text": "Module and function documentation is generated using  LDoc . See the existing modules for examples.", 
            "title": "Documentation"
        }, 
        {
            "location": "/reference/about_modules/#notes", 
            "text": "The list of reserved parameters:   comment  debug  test  syslog  log  handle  register  context  notify  notify_failed  notify_kept     It is the module's responsibility to determine whether anything needs to be done. An operation that modifies the system state should be convergent.    Modules are auto-loaded based on the name of the called module function. For example in a script containing the following snippet, module  example  is auto-loaded.    example.present subject \n  task:  yes     When writing modules run it through the excellent linting tool, Luacheck  https://github.com/mpeterv/luacheck/ .    Remember that a configuration management software's real strength comes from the quality of its modules.", 
            "title": "Notes"
        }, 
        {
            "location": "/reference/stdlib/", 
            "text": "Generated by LDoc\n\uf0c1\n\n\nStandard library documentation", 
            "title": "Standard library"
        }, 
        {
            "location": "/reference/stdlib/#generated-by-ldoc", 
            "text": "Standard library documentation", 
            "title": "Generated by LDoc"
        }, 
        {
            "location": "/reference/modules/", 
            "text": "Available Lua modules\n\uf0c1\n\n\nThese can be called in Configi modules.\n\n\n\n\nLuaposix\n\n\ncrc32\n\n\nsha2\n\n\ninotify\n\n\nlpeg", 
            "title": "Available Lua modules"
        }, 
        {
            "location": "/reference/modules/#available-lua-modules", 
            "text": "These can be called in Configi modules.   Luaposix  crc32  sha2  inotify  lpeg", 
            "title": "Available Lua modules"
        }, 
        {
            "location": "/reference/cli/", 
            "text": "Options of the cfg executable\n\uf0c1\n\n\n  cfg [-h] [-V] [-v] [-t] [-D] [-p N] [-s] [-l FILE] [-m] [-g TAG] [-r N] -f \nCONFIGI POLICY\n\n\n    Options:\n      -h, --help          This help text.\n      -V, --version       Print version.\n      -v, --debug         Turn on debugging messages.\n      -t, --test          Dry-run mode. All operations are expected to succeed. Turns on debugging.\n      -D, --daemon        Daemon mode. Watch for IN_MODIFY and IN_ATTRIB events to the policy file.\n      -p, --periodic      Do a run after N seconds.\n      -s, --syslog        Enable logging to syslog.\n      -l, --log           Log to an specified file.\n      -m, --msg           Show debug and test messages.\n      -g, --tag           Only run specified tag(s).\n      -r, --runs          Run the policy N times if a failure is encountered. Default is 3.\n      -f, --file          Path to the Configi policy.", 
            "title": "Cli"
        }, 
        {
            "location": "/reference/cli/#options-of-the-cfg-executable", 
            "text": "cfg [-h] [-V] [-v] [-t] [-D] [-p N] [-s] [-l FILE] [-m] [-g TAG] [-r N] -f  CONFIGI POLICY \n\n    Options:\n      -h, --help          This help text.\n      -V, --version       Print version.\n      -v, --debug         Turn on debugging messages.\n      -t, --test          Dry-run mode. All operations are expected to succeed. Turns on debugging.\n      -D, --daemon        Daemon mode. Watch for IN_MODIFY and IN_ATTRIB events to the policy file.\n      -p, --periodic      Do a run after N seconds.\n      -s, --syslog        Enable logging to syslog.\n      -l, --log           Log to an specified file.\n      -m, --msg           Show debug and test messages.\n      -g, --tag           Only run specified tag(s).\n      -r, --runs          Run the policy N times if a failure is encountered. Default is 3.\n      -f, --file          Path to the Configi policy.", 
            "title": "Options of the cfg executable"
        }, 
        {
            "location": "/reference/factid/", 
            "text": "Factid\n\uf0c1", 
            "title": "Factid"
        }, 
        {
            "location": "/reference/factid/#factid", 
            "text": "", 
            "title": "Factid"
        }, 
        {
            "location": "/reference/glossary/", 
            "text": "Policy\n\uf0c1\n\n\nA specification of a hosts desired state. Technically Configi policies are executable Lua scripts.\n\n\nPromise\n\uf0c1\n\n\nThe building blocks of policies. A promised describes the state of a specific aspect of a host.\n\n\nOperation\n\uf0c1\n\n\nAn operation is a unit of execution that may comprise a promise. There can be several operations to satisfy a promise.\n\n\nFor example calling \nmkdir\n from a Configi module function is an operation.\n\n\nModule\n\uf0c1\n\n\nConfigi modules are regular Lua modules that provides the functions required to deliver a promise.", 
            "title": "Glossary"
        }, 
        {
            "location": "/reference/glossary/#policy", 
            "text": "A specification of a hosts desired state. Technically Configi policies are executable Lua scripts.", 
            "title": "Policy"
        }, 
        {
            "location": "/reference/glossary/#promise", 
            "text": "The building blocks of policies. A promised describes the state of a specific aspect of a host.", 
            "title": "Promise"
        }, 
        {
            "location": "/reference/glossary/#operation", 
            "text": "An operation is a unit of execution that may comprise a promise. There can be several operations to satisfy a promise.  For example calling  mkdir  from a Configi module function is an operation.", 
            "title": "Operation"
        }, 
        {
            "location": "/reference/glossary/#module", 
            "text": "Configi modules are regular Lua modules that provides the functions required to deliver a promise.", 
            "title": "Module"
        }, 
        {
            "location": "/reference/gotchas/", 
            "text": "Gotchas\n\uf0c1\n\n\nNo conflict resolution\n - The last promise wins. Sometimes you would want to do start something and later on stop it.\n\n\nNo timeout on operations\n - At the moment Configi relies on the operation to timeout itself.", 
            "title": "Gotchas"
        }, 
        {
            "location": "/reference/gotchas/#gotchas", 
            "text": "No conflict resolution  - The last promise wins. Sometimes you would want to do start something and later on stop it.  No timeout on operations  - At the moment Configi relies on the operation to timeout itself.", 
            "title": "Gotchas"
        }, 
        {
            "location": "/reference/module_functions/", 
            "text": "Module Functions\n\uf0c1\n\n\nThis functions are available for modules.\n\n\nThese are returned by the \nF\n table as returned by \ncfg.init()\n. So \nmsg()\n is called as \nF.msg()\n\n\n\n\nmsg(s, s, b)\n\uf0c1\n\n\nGiven a string as the first argument, it becomes the \nitem\n field in the Configi messages. A string as second argument becomes the primary message for the operation as shown in the Configi messages and syslog. The boolean third argument indicates the operation status.\n\n\n\n\n\n\n\n\nBoolean\n\n\nStatus\n\n\n\n\n\n\n\n\n\n\ntrue\n\n\nrepaired\n\n\n\n\n\n\nfalse\n\n\nfailed\n\n\n\n\n\n\nnil\n\n\nkept\n\n\n\n\n\n\n\n\n\n\nrun(f, a)\n\uf0c1\n\n\nWraps the function(argument) and modifies the execution depending on the status of the debug (-v) and/or test (-t) flags.\n\n\nWhen debug is on, it add timing information for each operation. If test is on, operations are a noop.\n\n\n\n\nxrun(f, a)\n\uf0c1\n\n\nSame as \nrun\n but always assumes that debug is on.\n\n\n\n\nopen(u)\n\uf0c1\n\n\nWraps \nlib.fopen\n so the open operation is relative to the path of the policy location.\n\n\n\n\nkept(s)\n\uf0c1\n\n\nUsed when returning from a module function eg. \nreturn F.kept(s)\n. Enables handling of the \nnotify_kept\n parameter and returns the result as if the promise is kept or the operation was skipped.\n\n\n\n\nresult(s, b, m)\n\uf0c1\n\n\nUsed when returning from a module function eg. \nreturn F.result(s, b)\n. Depending on the boolean return value of the second argument. If \ntrue\n then it enables the handling of the \nnotify\n parameter and returns the result as if the promise was repaired. If \nfalse\n then it enables the handling of the \nnotify_failed\n parameter and returns the result as if the promise failed. If \nnil\n then it enables the handling of the \nnotify_kept\n parameter and returns the result as if the promise was kept or the operation was skipped.\n\n\nAn optional third argument represented as a string can be passed if you want to show a message that is not in the \nM.report\n table.", 
            "title": "Module functions"
        }, 
        {
            "location": "/reference/module_functions/#module-functions", 
            "text": "This functions are available for modules.  These are returned by the  F  table as returned by  cfg.init() . So  msg()  is called as  F.msg()", 
            "title": "Module Functions"
        }, 
        {
            "location": "/reference/module_functions/#msgs-s-b", 
            "text": "Given a string as the first argument, it becomes the  item  field in the Configi messages. A string as second argument becomes the primary message for the operation as shown in the Configi messages and syslog. The boolean third argument indicates the operation status.     Boolean  Status      true  repaired    false  failed    nil  kept", 
            "title": "msg(s, s, b)"
        }, 
        {
            "location": "/reference/module_functions/#runf-a", 
            "text": "Wraps the function(argument) and modifies the execution depending on the status of the debug (-v) and/or test (-t) flags.  When debug is on, it add timing information for each operation. If test is on, operations are a noop.", 
            "title": "run(f, a)"
        }, 
        {
            "location": "/reference/module_functions/#xrunf-a", 
            "text": "Same as  run  but always assumes that debug is on.", 
            "title": "xrun(f, a)"
        }, 
        {
            "location": "/reference/module_functions/#openu", 
            "text": "Wraps  lib.fopen  so the open operation is relative to the path of the policy location.", 
            "title": "open(u)"
        }, 
        {
            "location": "/reference/module_functions/#kepts", 
            "text": "Used when returning from a module function eg.  return F.kept(s) . Enables handling of the  notify_kept  parameter and returns the result as if the promise is kept or the operation was skipped.", 
            "title": "kept(s)"
        }, 
        {
            "location": "/reference/module_functions/#results-b-m", 
            "text": "Used when returning from a module function eg.  return F.result(s, b) . Depending on the boolean return value of the second argument. If  true  then it enables the handling of the  notify  parameter and returns the result as if the promise was repaired. If  false  then it enables the handling of the  notify_failed  parameter and returns the result as if the promise failed. If  nil  then it enables the handling of the  notify_kept  parameter and returns the result as if the promise was kept or the operation was skipped.  An optional third argument represented as a string can be passed if you want to show a message that is not in the  M.report  table.", 
            "title": "result(s, b, m)"
        }, 
        {
            "location": "/reference/policy_functions/", 
            "text": "Policy Functions\n\uf0c1\n\n\nThese functions are available for all policies.\n\n\n\n\nipairs(t)\n\uf0c1\n\n\nSame as Lua ipairs(). From the Lua Reference Manual:\n\n\nReturns three values: an iterator function, the table t, and 0, so that the construction\n\n\nfor i,v in ipairs(t) do body end\n\n\n\nwill iterate over the pairs (1,t[1]), (2,t[2]), ..., up to the first integer key absent from the table.\n\n\n\n\npairs(t)\n\uf0c1\n\n\nSame as Lua pairs(). From the Lua Reference Manual:\n\n\nReturns three values: the next function, the table t, and nil, so that the construction\n\n\n for k,v in pairs(t) do body end\n\n\n\nwill iterate over all key\u2013value pairs of table t.\n\n\n\n\nlist(t)\n\uf0c1\n\n\nGiven a table \nt\n, iterate over this table and return a line terminated \nfield \"value\"\n pair.\n\n\nFor instance the following snippet\n\n\nd = {\n  [\"/tmp/one\"]: { comment: \"one\" }\n  [\"/tmp/two\"]: { comment = \"two\" }\n}\n\nfor dirs,params in list(d)\n  file.absent(dirs)(params)\n\n\n\nis equivalent to\n\n\nfile.absent\"/tmp/one\"\n  comment: \"one\"\n\nfile.absent\"/tmp/two\"\n  comment: \"two\"\n\n\n\n\n\nsub(s, t)\n\uf0c1\n\n\nSimple string interpolation.\n\n\nGiven a table \nt\n, interpolate the string \ns\n by replacing corresponding field names with the respective value.\n\n\ntbl = { \"field\" = \"value\" }\nstr = [[ this is the {{ field }} ]]\n\n\n\nIf passed with these arguments, a new string is returned as\n\n\n'this is the value'\n\n\n\n\n\nformat(s, ...)\n\uf0c1\n\n\nSame as Lua string.format(). From the Lua Reference Manual:\n\n\nReturns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ANSI C function sprintf. The only differences are that the options/modifiers *, h, L, l, n, and p are not supported and that there is an extra option, q. The q option formats a string between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call\n\n\nformat('%q', 'a string with \"quotes\" and \\n new line')\n\n\n\nmay produce the string:\n\n\n\"a string with \\\"quotes\\\" and \\\n  new line\"\n\n\n\nOptions A and a (when available), E, e, f, G, and g all expect a number as argument. Options c, d, i, o, u, X, and x also expect a number, but the range of that number may be limited by the underlying C implementation. For options o, u, X, and x, the number cannot be negative. Option q expects a string; option s expects a string without embedded zeros. If the argument to option s is not a string, it is converted to one following the same rules of tostring.\n\n\n\n\ndebug(s)\n\uf0c1\n\n\nTurn on debugging if passed any of the strings \nyes\n, \nYes\n, \ntrue,\n or \nTrue\n.\n\n\n\n\ntest(s)\n\uf0c1\n\n\nTurn on dry-run mode if passed any of the strings \nyes\n, \nYes\n, \ntrue\n, or \nTrue\n.\n\n\n\n\nsyslog(s)\n\uf0c1\n\n\nTurn on syslogging if passed any of the strings \nyes\n, \nYes\n, \ntrue\n, or \nTrue\n.\n\n\n\n\nlog(s)\n\uf0c1\n\n\nTurn on logging to a file.\n\n\nThe string \ns\n is the path to a file.\n\n\n\n\ninclude(s)\n\uf0c1\n\n\nInclude another Configi policy. The string \ns\n is the path to a file.\n\n\nIncluded policies are stacked, for example the following policy inserts the contents of \ntest1.lua\n then \ntest2.lua\n at the top.\n\n\ninclude\"test1.lua\"\ninclude\"test2.lua\"\nfile.touch\"/etc/passwd\"!\n\n\n\n\n\neach(t, f)\n\uf0c1\n\n\nRun a function \nf\n against each item from table \nt\n.\n\n\nThe following:\n\n\nt = {\n  [\"test.xxx\"] = { comment: \"test\" },\n  [\"test.yyy\"] = { comment: \"test\" }\n}\n\neach(t, file.absent)\n\n\n\nis equivalent to\n\n\nfile.absent\"test.xxx\"\n  comment: \"test\"\n\nfile.absent\"test.yyy\"\n  comment: \"test\"", 
            "title": "Policy functions"
        }, 
        {
            "location": "/reference/policy_functions/#policy-functions", 
            "text": "These functions are available for all policies.", 
            "title": "Policy Functions"
        }, 
        {
            "location": "/reference/policy_functions/#ipairst", 
            "text": "Same as Lua ipairs(). From the Lua Reference Manual:  Returns three values: an iterator function, the table t, and 0, so that the construction  for i,v in ipairs(t) do body end  will iterate over the pairs (1,t[1]), (2,t[2]), ..., up to the first integer key absent from the table.", 
            "title": "ipairs(t)"
        }, 
        {
            "location": "/reference/policy_functions/#pairst", 
            "text": "Same as Lua pairs(). From the Lua Reference Manual:  Returns three values: the next function, the table t, and nil, so that the construction   for k,v in pairs(t) do body end  will iterate over all key\u2013value pairs of table t.", 
            "title": "pairs(t)"
        }, 
        {
            "location": "/reference/policy_functions/#listt", 
            "text": "Given a table  t , iterate over this table and return a line terminated  field \"value\"  pair.  For instance the following snippet  d = {\n  [\"/tmp/one\"]: { comment: \"one\" }\n  [\"/tmp/two\"]: { comment = \"two\" }\n}\n\nfor dirs,params in list(d)\n  file.absent(dirs)(params)  is equivalent to  file.absent\"/tmp/one\"\n  comment: \"one\"\n\nfile.absent\"/tmp/two\"\n  comment: \"two\"", 
            "title": "list(t)"
        }, 
        {
            "location": "/reference/policy_functions/#subs-t", 
            "text": "Simple string interpolation.  Given a table  t , interpolate the string  s  by replacing corresponding field names with the respective value.  tbl = { \"field\" = \"value\" }\nstr = [[ this is the {{ field }} ]]  If passed with these arguments, a new string is returned as  'this is the value'", 
            "title": "sub(s, t)"
        }, 
        {
            "location": "/reference/policy_functions/#formats", 
            "text": "Same as Lua string.format(). From the Lua Reference Manual:  Returns a formatted version of its variable number of arguments following the description given in its first argument (which must be a string). The format string follows the same rules as the ANSI C function sprintf. The only differences are that the options/modifiers *, h, L, l, n, and p are not supported and that there is an extra option, q. The q option formats a string between double quotes, using escape sequences when necessary to ensure that it can safely be read back by the Lua interpreter. For instance, the call  format('%q', 'a string with \"quotes\" and \\n new line')  may produce the string:  \"a string with \\\"quotes\\\" and \\\n  new line\"  Options A and a (when available), E, e, f, G, and g all expect a number as argument. Options c, d, i, o, u, X, and x also expect a number, but the range of that number may be limited by the underlying C implementation. For options o, u, X, and x, the number cannot be negative. Option q expects a string; option s expects a string without embedded zeros. If the argument to option s is not a string, it is converted to one following the same rules of tostring.", 
            "title": "format(s, ...)"
        }, 
        {
            "location": "/reference/policy_functions/#debugs", 
            "text": "Turn on debugging if passed any of the strings  yes ,  Yes ,  true,  or  True .", 
            "title": "debug(s)"
        }, 
        {
            "location": "/reference/policy_functions/#tests", 
            "text": "Turn on dry-run mode if passed any of the strings  yes ,  Yes ,  true , or  True .", 
            "title": "test(s)"
        }, 
        {
            "location": "/reference/policy_functions/#syslogs", 
            "text": "Turn on syslogging if passed any of the strings  yes ,  Yes ,  true , or  True .", 
            "title": "syslog(s)"
        }, 
        {
            "location": "/reference/policy_functions/#logs", 
            "text": "Turn on logging to a file.  The string  s  is the path to a file.", 
            "title": "log(s)"
        }, 
        {
            "location": "/reference/policy_functions/#includes", 
            "text": "Include another Configi policy. The string  s  is the path to a file.  Included policies are stacked, for example the following policy inserts the contents of  test1.lua  then  test2.lua  at the top.  include\"test1.lua\"\ninclude\"test2.lua\"\nfile.touch\"/etc/passwd\"!", 
            "title": "include(s)"
        }, 
        {
            "location": "/reference/policy_functions/#eacht-f", 
            "text": "Run a function  f  against each item from table  t .  The following:  t = {\n  [\"test.xxx\"] = { comment: \"test\" },\n  [\"test.yyy\"] = { comment: \"test\" }\n}\n\neach(t, file.absent)  is equivalent to  file.absent\"test.xxx\"\n  comment: \"test\"\n\nfile.absent\"test.yyy\"\n  comment: \"test\"", 
            "title": "each(t, f)"
        }
    ]
}